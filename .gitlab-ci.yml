# GitLab CI/CD Pipeline
# Automated testing, building, and deployment for microservices platform

variables:
  # Container Registry
  CI_REGISTRY: $CI_REGISTRY
  CI_REGISTRY_IMAGE: $CI_REGISTRY_IMAGE
  CI_REGISTRY_USER: $CI_REGISTRY_USER
  CI_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
  
  # Docker
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_DRIVER: overlay2
  
  # Go
  GO_VERSION: "1.21"
  
  # Node
  NODE_VERSION: "20"

stages:
  - test
  - security
  - build
  - deploy

# ============================================================================
# Templates
# ============================================================================

.docker_template: &docker_template
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

.go_template: &go_template
  image: golang:${GO_VERSION}
  before_script:
    - go version

.node_template: &node_template
  image: node:${NODE_VERSION}
  before_script:
    - node --version
    - npm --version

# ============================================================================
# Test Stage
# ============================================================================

test:backend:
  <<: *go_template
  stage: test
  services:
    - postgres:16-alpine
    - redis:7-alpine
    - rabbitmq:3-management-alpine
  variables:
    POSTGRES_DB: test_db
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: test_password
    DB_HOST: postgres
    DB_PORT: 5432
    DB_USER: postgres
    DB_PASSWORD: test_password
    DB_NAME: test_db
    REDIS_HOST: redis:6379
    RABBITMQ_HOST: rabbitmq:5672
  script:
    - cd microservices/order-service
    - go mod download
    - go test -v -cover -coverprofile=coverage.out ./...
    - go tool cover -html=coverage.out -o coverage.html
  coverage: '/coverage: \d+.\d+% of statements/'
  artifacts:
    paths:
      - microservices/order-service/coverage.html
      - microservices/order-service/coverage.out
    reports:
      coverage_report:
        coverage_format: cobertura
        path: microservices/order-service/coverage.out
    expire_in: 30 days
  only:
    - merge_requests
    - main
    - develop

test:frontend:
  <<: *node_template
  stage: test
  script:
    - cd client
    - npm ci --prefer-offline --no-audit
    - npm run lint
    - npx tsc --noEmit || echo "TypeScript errors found but continuing..."
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - client/node_modules/
  artifacts:
    paths:
      - client/.next/
    expire_in: 1 day
  only:
    - merge_requests
    - main
    - develop

# ============================================================================
# Security Stage
# ============================================================================

security:trivy:
  stage: security
  image: aquasec/trivy:latest
  script:
    - trivy --version
    # Scan repository for vulnerabilities
    - trivy fs --exit-code 0 --severity HIGH,CRITICAL --no-progress ./microservices
    - trivy fs --exit-code 0 --severity HIGH,CRITICAL --no-progress ./client
  allow_failure: true
  only:
    - merge_requests
    - main

security:gosec:
  <<: *go_template
  stage: security
  script:
    - go install github.com/securego/gosec/v2/cmd/gosec@latest
    - cd microservices
    - gosec -fmt json -out gosec-report.json ./... || true
    - gosec ./...
  artifacts:
    paths:
      - microservices/gosec-report.json
    expire_in: 30 days
  allow_failure: true
  only:
    - merge_requests
    - main

security:npm-audit:
  <<: *node_template
  stage: security
  script:
    - cd client
    - npm audit --audit-level=high || true
  allow_failure: true
  only:
    - merge_requests
    - main

# ============================================================================
# Build Stage
# ============================================================================

build:api-gateway:
  <<: *docker_template
  stage: build
  script:
    - cd microservices
    - |
      docker build \
        -t $CI_REGISTRY_IMAGE/api-gateway:$CI_COMMIT_SHORT_SHA \
        -t $CI_REGISTRY_IMAGE/api-gateway:latest \
        -f api-gateway/Dockerfile \
        .
    - docker push $CI_REGISTRY_IMAGE/api-gateway:$CI_COMMIT_SHORT_SHA
    - docker push $CI_REGISTRY_IMAGE/api-gateway:latest
  only:
    - main
    - develop

build:auth-service:
  <<: *docker_template
  stage: build
  script:
    - cd microservices
    - |
      docker build \
        -t $CI_REGISTRY_IMAGE/auth-service:$CI_COMMIT_SHORT_SHA \
        -t $CI_REGISTRY_IMAGE/auth-service:latest \
        -f auth-service/Dockerfile \
        .
    - docker push $CI_REGISTRY_IMAGE/auth-service:$CI_COMMIT_SHORT_SHA
    - docker push $CI_REGISTRY_IMAGE/auth-service:latest
  only:
    - main
    - develop

build:product-service:
  <<: *docker_template
  stage: build
  script:
    - cd microservices
    - |
      docker build \
        -t $CI_REGISTRY_IMAGE/product-service:$CI_COMMIT_SHORT_SHA \
        -t $CI_REGISTRY_IMAGE/product-service:latest \
        -f product-service/Dockerfile \
        .
    - docker push $CI_REGISTRY_IMAGE/product-service:$CI_COMMIT_SHORT_SHA
    - docker push $CI_REGISTRY_IMAGE/product-service:latest
  only:
    - main
    - develop

build:order-service:
  <<: *docker_template
  stage: build
  script:
    - cd microservices
    - |
      docker build \
        -t $CI_REGISTRY_IMAGE/order-service:$CI_COMMIT_SHORT_SHA \
        -t $CI_REGISTRY_IMAGE/order-service:latest \
        -f order-service/Dockerfile \
        .
    - docker push $CI_REGISTRY_IMAGE/order-service:$CI_COMMIT_SHORT_SHA
    - docker push $CI_REGISTRY_IMAGE/order-service:latest
  only:
    - main
    - develop

build:client:
  <<: *docker_template
  stage: build
  script:
    - cd client
    - |
      docker build \
        -t $CI_REGISTRY_IMAGE/client:$CI_COMMIT_SHORT_SHA \
        -t $CI_REGISTRY_IMAGE/client:latest \
        .
    - docker push $CI_REGISTRY_IMAGE/client:$CI_COMMIT_SHORT_SHA
    - docker push $CI_REGISTRY_IMAGE/client:latest
  only:
    - main
    - develop

build:nginx:
  <<: *docker_template
  stage: build
  script:
    - cd microservices/nginx
    - |
      docker build \
        -t $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHORT_SHA \
        -t $CI_REGISTRY_IMAGE/nginx:latest \
        .
    - docker push $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHORT_SHA
    - docker push $CI_REGISTRY_IMAGE/nginx:latest
  only:
    - main
    - develop

# ============================================================================
# Deploy Stage
# ============================================================================

deploy:staging:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - echo "Deploying to staging environment..."
    # Configure kubectl
    - mkdir -p ~/.kube
    - echo "$KUBE_CONFIG_STAGING" | base64 -d > ~/.kube/config
    - kubectl config use-context staging
    
    # Update image tags
    - kubectl set image deployment/api-gateway api-gateway=$CI_REGISTRY_IMAGE/api-gateway:$CI_COMMIT_SHORT_SHA -n microservices
    - kubectl set image deployment/auth-service auth-service=$CI_REGISTRY_IMAGE/auth-service:$CI_COMMIT_SHORT_SHA -n microservices
    - kubectl set image deployment/product-service product-service=$CI_REGISTRY_IMAGE/product-service:$CI_COMMIT_SHORT_SHA -n microservices
    - kubectl set image deployment/order-service order-service=$CI_REGISTRY_IMAGE/order-service:$CI_COMMIT_SHORT_SHA -n microservices
    - kubectl set image deployment/client client=$CI_REGISTRY_IMAGE/client:$CI_COMMIT_SHORT_SHA -n microservices
    - kubectl set image deployment/nginx nginx=$CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHORT_SHA -n microservices
    
    # Wait for rollout
    - kubectl rollout status deployment/api-gateway -n microservices
    - kubectl rollout status deployment/client -n microservices
    
    # Verify deployment
    - kubectl get pods -n microservices
  environment:
    name: staging
    url: https://staging.yourdomain.com
  only:
    - develop
  when: manual

deploy:production:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - echo "Deploying to production environment..."
    # Configure kubectl
    - mkdir -p ~/.kube
    - echo "$KUBE_CONFIG_PROD" | base64 -d > ~/.kube/config
    - kubectl config use-context production
    
    # Update image tags
    - kubectl set image deployment/api-gateway api-gateway=$CI_REGISTRY_IMAGE/api-gateway:$CI_COMMIT_SHORT_SHA -n microservices
    - kubectl set image deployment/auth-service auth-service=$CI_REGISTRY_IMAGE/auth-service:$CI_COMMIT_SHORT_SHA -n microservices
    - kubectl set image deployment/product-service product-service=$CI_REGISTRY_IMAGE/product-service:$CI_COMMIT_SHORT_SHA -n microservices
    - kubectl set image deployment/order-service order-service=$CI_REGISTRY_IMAGE/order-service:$CI_COMMIT_SHORT_SHA -n microservices
    - kubectl set image deployment/client client=$CI_REGISTRY_IMAGE/client:$CI_COMMIT_SHORT_SHA -n microservices
    - kubectl set image deployment/nginx nginx=$CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHORT_SHA -n microservices
    
    # Wait for rollout
    - kubectl rollout status deployment/api-gateway -n microservices --timeout=5m
    - kubectl rollout status deployment/client -n microservices --timeout=5m
    
    # Verify deployment
    - kubectl get pods -n microservices
    - kubectl get svc -n microservices
  environment:
    name: production
    url: https://yourdomain.com
  only:
    - main
  when: manual
  needs:
    - deploy:staging
